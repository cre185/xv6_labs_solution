## Lab 3    
[Lab 3 官方文档](https://pdos.csail.mit.edu/6.828/2022/labs/pgtbl.html)  
[xv6 源码](https://github.com/mit-pdos/xv6-public)   
[完成工程仓库](https://github.com/cre185/xv6_labs_solution)
***
在开始本Lab的操作前，先使用以下代码将git转至syscall分支：  
```
git fetch
git checkout pgtbl  
make clean
```
***
#### Speed up system calls  
要求在每个进程创建的时候附带生成一个usyscall结构体，并向其中存入当前进程的pid。  
提示中给出了几个相关的函数以及实现要点，下面对这些提示进行分析。  
##### proc_pagetable  
该函数创建页表并初始化trampoline和trapframe两个值，观察这两个值的所谓初始化过程可以发现调用了一个名为mappages的函数，不难看出这一函数是用于建立由某一地址到某页表的映射的，符合我们的需求。  
##### permission bits  
该提示的意思是设置PTE标志位时要满足我们当前的需求，也即允许用户空间访问且只读两个要点。这里又要参考[这篇文章](https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html)里的图片了，下面直接放上了图：  
![pic](res/pte.png)
下面是PTE中标志位的含义及其名称，可以看出我们需要PTE-U标志。另外还需要可读标记，这个标记不知道为什么没有在图中标出，一方面看到PTE-W是写标记也能猜出PTE-R是读标记，另一方面上面的proc_pagetable函数中刚好用到了这个猜想的PTE-R，两边一拍即合，可以确认这个PTE-R就是我们需要的可读标记。  
##### mappages  
这个提示还专门强调了一下上面发现的mappages函数，这下确凿无疑要使用该函数了。  
##### allocproc和freeproc  
两个函数分别负责分配一页内存以及回收它，实现功能时这两个函数分别也需要修改，创建时初始化维护以及结束时的回收空间工作不要忘记。  
##### 具体实现  
任务需要创建一个usyscall结构体，这个结构体的初始化在allocproc中实现，而又需要在proc_pagetable中使用，此处直接将变量声明在proc结构体中方便使用。  
在`proc.h`中添加`struct usyscall *scall;`语句后，依次修改四个函数（上面说了三个，还有一个对称的proc_freepagetable自然也需要处理），这部分的实现较为简单，各自仿照同一函数内的例子即可，此处的修改后代码放在了speedup文件夹内。  
***  
#### print a page table  
任务要求实现vmprint函数，负责按一定的格式打印页表的内容。  
此外，在`exec.c`中加入`if(p->pid==1) vmprint(p->pagetable)`语句来打印第一个进程的页表，这一步照做即可。  
##### `vm.c`  
第一个提示告诉我们将vmprint的实现放在`vm.c`文件中，实际上下面还有一条提示：freewalk函数可以得到利用。仔细观察一下freewalk的实现可以发现，这个函数递归地释放一个页表项下面所有的页表，而我们需要递归地打印所有页表情况，这一点很明显可以借鉴freewalk中的递归实现。   
##### `riscv.h`  
该文件末尾的宏定义将有所帮助，查看文件末尾发现有着PTE2PA这个宏定义，实际上这个定义在freewalk中已经得到了使用，我们可以在实现过程中进行模仿。  
##### `defs.h`  
提示将定义放在`defs.h`头文件中，照做即可。  
##### 输出格式  
在printf函数中使用%p可以打印出十六进制数字，以实现如同输出示例的输出效果。  
##### 实现  
首先复制一份freewalk，然后综合一下上面了解到的情况。  
输出需要根据当前是第几层pagetable输出相应个数的点，所以先需要增添一个变量记录深度。特别的，深度为0也即第一次输出时使用特殊的输出格式。  
记录深度的变量被我放置在函数的外部，声明为静态变量以在函数内进行引用，并初始化为0。  
在遍历所有页表时，PTE_V表明该页表为有效状态，将带有这一标签的页表输出即可，并依靠深度变量在前面按正确格式输出布局。  
下面的递归部分注意维护深度变化，采用深搜中的深度维护方法即可（进递归前+1，退出来立刻-1）。  
vmprint的实现放置于print文件夹中。  
*** 
#### detect which pages have been accessed  
需要实现pgaccess函数，该函数为一个系统调用，并返回哪些页已经被访问过了。  
该函数接受三个参数：起始页位置、要检查的页数量以及存放结果的地址。  
##### pgaccess_test  
直接阅读`pgtbltest.c`以了解如何使用pgaccess，还挺直接的手段。  
提示中点明了关于这个所谓存放结果的地址的形式，实际上是位掩码，使用一个uint表达32个页的信息。在弄明白这一点之后，就能看懂测试程序中的通过要求了。  
##### sysproc  
新增系统调用第一步，在`sysproc.c`中加入函数，这一点做过Lab2 syscall的已经比较熟悉了，不再多言，下面的使用argint和argaddr也一样。  
（仓库中的文件甚至已经帮你建立好了空函数）  
##### 位掩码管理  
提示中建议在内核空间中建立临时变量管理位掩码，然后调用copyout函数从用户空间获取到该数值即可。  
##### 扫描页上限  
可以给一次扫描的页数上限进行限制，此处我没有添加限制。  
##### walk  
walk函数（位于`vm.c`中）对于寻找PTE会有帮助，阅读walk函数的源码，可知该函数接受页表及虚拟地址，返回找到的PTE的物理地址。也可以参考[这篇文档](https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf)的第36页，有一点对walk函数的描述。alloc参数表示如果页表不存在是否需要分配内存，此处传入0表示不需要即可。    
获取PTE的物理地址有什么用处呢？下面的一个提示又说我们需要获取PTE_A的值，这里参考官方的文档可以了解到情况，大概的结构如下图所示。  
![pic](res/_pte.png)
PTE_A在位置6处，根据文档说明，该值直接指示了页表有无被访问的记录，值为1则已被访问。这一点可以说解决了我们的核心问题，即如何确定页表是否被访问过。  
##### PTE_A  
然而这个PTE_A虽然在程序内核被保存了，却并没有一个定义让我们访问它，于是在`riscv.h`中国需要加入PTE_A的定义，有了上面的这张图，再结合原有的定义，将PTE_A定义中的位运算数字改为6即可。  
下一个提示也很简单，就是访问完后需要将PTE_A设置为0，毕竟我们为了检查而进行了访问，这一访问过程本身就影响到了PTE_A的值，因此别忘了把它置零。  
##### vmprint  
最后的提示是上一步实现的vmprint函数可能会在调试时有帮助，调试时记得可以使用。  
##### 实现  
总结一下上面的要点并整合：  
* 首先接收传入参数，根据参数列表定义，首先是一个va，用argaddr（uint64类型）；然后一个整数用argint；最后一个目标地址uint64还是得用argaddr   
* 初始化一个掩码（即uint mask=0），然后对指定数量个页进行遍历  
* 获取PTE依靠walk函数，获取之后检查PTE_A位的值  
* 使用后将PTE_A位值重置为0  
* 最后用copyout将值传到用户空间的目标地址中  

实现的函数位于pgaccess文件夹中。  
***
至此Lab 3任务全部完成。  
